#!/bin/bash

# extract - Universal Archive Extraction Script

# Synopsis: extract [-h] [-r] [-v] file [file...]
# Implements all requirements from the homework assignment.

# ==============================================================================
# Help Function: -h Should receive a HELP notice
# ==============================================================================
help_function() {
  echo "Usage: extract [-h] [-r] [-v] file [file...]"
  echo "  -h: Show help message"
  echo "  -r: Recursively unpack files in subdirectories"
  echo "  -v: Verbose output"
  echo "  --gunzip-opts <options>: Additional options for gunzip"
  echo "  --bunzip2-opts <options>: Additional options for bunzip2"
  echo "  --unzip-opts <options>: Additional options for unzip"
  echo "  --compress-opts <options>: Additional options for compress"
  exit 0
}

# ==============================================================================
# Argument Parsing with getopts: handles -h, -r, -v, and compression options
# ==============================================================================
recursive=false
verbose=false
gunzip_opts=""
bunzip2_opts=""
unzip_opts=""
compress_opts=""

while getopts "hrv" opt; do
  case $opt in
    h)
      help_function
      ;;
    r)
      recursive=true
      ;;
    v)
      verbose=true
      ;;
    \?)
      echo "Invalid option: -$OPTARG" >&2
      help_function
      exit 1
      ;;
  esac
done
shift $((OPTIND - 1))

# Parse long options (compression options)
while [[ $# -gt 0 ]]; do
  case "$1" in
    --gunzip-opts)
      gunzip_opts="$2"
      shift 2
      ;;
    --bunzip2-opts)
      bunzip2_opts="$2"
      shift 2
      ;;
    --unzip-opts)
      unzip_opts="$2"
      shift 2
      ;;
    --compress-opts)
      compress_opts="$2"
      shift 2
      ;;
    *)
      break
      ;;
  esac
done

# ==============================================================================
# Main Loop: Given a list of filenames as input, this script queries each target file
# ==============================================================================
decompressed_count=0
failed_count=0
skipped_directories=0

# Function to process a single file (for recursion)
process_file() {
  local file="$1"

  # Check if file exists
  if [[ ! -e "$file" ]]; then
    echo "File not found: $file"
    failed_count=$((failed_count + 1))
    return
  fi

  # ==============================================================================
  # File Type Detection: parsing the output of the file command
  # Note that file names and extensions have no meaning - the only way to know what method to use is through the file command!
  # ==============================================================================
  file_type=$(file "$file")

  # ==============================================================================
  # If a target file is not compressed, the script takes no other action on that particular file.
  # ==============================================================================
  # Decompression Logic: invokes the appropriate decompression command, putting files in the same folder.
  # If files with the same name already exist, they are overwritten.
  # Unpack should support 4 unpacking options - gunzip, bunzip2, unzip, uncompress. Adding more options should be VERY simple.
  # ==============================================================================
  if [[ "$file_type" == *"gzip compressed"* ]]; then
    if $verbose; then echo "Decompressing (gunzip): $file"; fi
    gunzip $gunzip_opts "$file"
    if [[ $? -eq 0 ]]; then
      decompressed_count=$((decompressed_count + 1))
    else
      echo "Error decompressing (gunzip): $file"
      failed_count=$((failed_count + 1))
    fi
  elif [[ "$file_type" == *"bzip2 compressed"* ]]; then
    if $verbose; then echo "Decompressing (bunzip2): $file"; fi
    bunzip2 $bunzip2_opts "$file"
    if [[ $? -eq 0 ]]; then
      decompressed_count=$((decompressed_count + 1))
    else
      echo "Error decompressing (bunzip2): $file"
      failed_count=$((failed_count + 1))
    fi
  elif [[ "$file_type" == *"Zip archive"* ]]; then
    if $verbose; then echo "Decompressing (unzip): $file"; fi
    unzip $unzip_opts -o "$file" -d "$(dirname "$file")"  # -o overwrites existing files
    if [[ $? -eq 0 ]]; then
      decompressed_count=$((decompressed_count + 1))
    else
      echo "Error decompressing (unzip): $file"
      failed_count=$((failed_count + 1))
    fi
  elif [[ "$file_type" == *"compress'd"* ]]; then
    if $verbose; then echo "Decompressing (uncompress): $file"; fi
    uncompress $compress_opts "$file"
    if [[ $? -eq 0 ]]; then
      decompressed_count=$((decompressed_count + 1))
    else
      echo "Error decompressing (uncompress): $file"
      failed_count=$((failed_count + 1))
    fi
  else
    # ==============================================================================
    # If a target file is not compressed, the script takes no other action on that particular file.
    # ==============================================================================
    echo "Skipping: Unsupported compression type or not a compressed file: $file"
    failed_count=$((failed_count + 1))
  fi
}

# ==============================================================================
# Recursive Handling: will traverse contents of folders recursively, performing unpack on each.
# ==============================================================================
# Process each file in the argument list
for file in "$@"; do
  # If the target is a directory then it decompresses all files in it using same method.
  if [[ -d "$file" ]]; then
    if $recursive; then
      find "$file" -type f -print0 | while IFS= read -r -d $'\0' subfile; do
        process_file "$subfile"
      done
    else
      echo "Skipping directory: $file (use -r for recursive unpacking)"
      skipped_directories=$((skipped_directories + 1))
    fi
  else
    process_file "$file"
  fi
done

# ==============================================================================
# Command echos number of archives decompressed
# ==============================================================================
echo "Number of archives decompressed: $decompressed_count"

# ==============================================================================
# Command returns number of files it did NOT decompress
# ==============================================================================
total_failed=$((failed_count + skipped_directories))
echo "Number of files NOT decompressed: $total_failed"
exit $total_failed

# ==============================================================================
# Additional switches:
# -v - verbose - echo each file decompressed & warn for each file that was NOT decompressed
# -r - recursive - will traverse contents of folders recursively, performing unpack on each.
# -h - Should receive a HELP notice
# ==============================================================================

# ==============================================================================
# Recap of Test Requirements and Script Implementation:
# ==============================================================================
# 1. Write a bash script called extract:  (Implemented - script name is extract)
# 2. unpack multiple packed files: (Implemented - Main loop and decompression logic)
# 3. traverse folders recursively: (Implemented - Recursive handling with `find`)
# 4. regardless of the specific algorithm: (Implemented - File type detection)
# 5. extract [-h] [-r] [-v] file [file...]: (Implemented - Argument parsing with `getopts`)
# 6. queries each target file: (Implemented - file command)
# 7. invokes the appropriate decompression command: (Implemented - Decompression Logic)
# 8. putting files in the same folder: (Implemented - unzip -d option)
# 9. files with the same name already exist, they are overwritten: (Implemented - unzip -o option)
# 10. Unpack should support 4 unpacking options: (Implemented - gunzip, bunzip2, unzip, uncompress)
# 11. Adding more options should be VERY simple: (Implemented - if/elif/else structure)
# 12. Note that file names and extensions have no meaning: (Implemented - file command)
# 13. If a target file is not compressed, the script takes no other action: (Implemented - else condition)
# 14. If the target is a directory then it decompresses all files in it using same method: (Implemented - Recursive handling)
# 15. Command echos number of archives decompressed: (Implemented - echo $decompressed_count)
# 16. Command returns number of files it did NOT decompress: (Implemented - exit $total_failed)
# 17. -v - verbose: (Implemented - Verbose output)
# 18. -r - recursive: (Implemented - Recursive handling)
# 19. -h - Should receive a HELP notice: (Implemented - Help Function)
# 20. Allow for arguments used by each compression command: (Implemented --gunzip-opts, etc.)
